{"name":"Multiplayer Hawkthorne","tagline":"","body":"# Journey to the Center of Hawkthorne\r\n\r\nThis project is a derivative of Kyle Conroy's [Journey to the Center of Hawkthorne](https://github.com/kyleconroy/hawkthorne-journey) project. Journey to the Center of Hawkthorne is a sidescrolling game based on community's Digital Estate Planning episode.\r\n\r\nWhere the main project focuses on single player campaign, this is multiple projects all designed with the aim of supporting multiplayer over a network.\r\n\r\n[Lua Server](https://github.com/NimbusBP1729/hawkthorne-server-lua)\r\n\r\n[Lua Client](https://github.com/NimbusBP1729/hawkthorne-client-lua)\r\n\r\n[Java Client](https://github.com/NimbusBP1729/hawkthorne-client-java) &mdash;\r\n[javadocs](../hawkthorne-client-java/doc)\r\n\r\nJava Server will be published sooner or later\r\n\r\nREADME for people who want to test it out without looking at code\r\nhttps://dl.dropbox.com/u/13978314/hawkthorne/README.txt\r\n\r\n# Communication Interface for Multiplayer Client/Server\r\n\r\nNote: the `entity` is an id assigned to the player when he tries to register. \r\n`obj` and `plyr` sent through the UDP sockets are packed representations of an object and a player respectively.\r\n\r\n## Supported commands and when they should be sent:\r\n### Client to Server\r\nwhen the client presses a button\r\n\r\n    (entity) keypressed (button)\r\n\r\nwhen the client releases a button\r\n\r\n    (entity) keyreleased (button)    \r\n\r\nwhen the client requests an update of level level_name Note: it is expected that the server responds with updatePlayer and updateObject\r\n\r\n     (entity) update (levelName)\r\n\r\nwhen the client registers a character by the name of (name) with costume (costume)\r\n\r\n    (entity) register (name) (costume)\r\n\r\nwhen the client switches to a character by the name of (name) with costume (costume)\r\n\r\n    (entity) changeCostume (name) (costume)\r\n\r\nwhen the client decides to enter a specific level\r\n\r\n    (entity) enter (level)    \r\n\r\n### Server to Client\r\n\r\nwhen the server gets a request from an entity to update this is sent to a single client\r\n\r\n    (entity) updatePlayer (plyr)\r\n\r\nwhen the server gets a request from an entity to update<br>\r\nthis is sent to a single client\r\n\r\n    (entity) updateObject (obj)    \r\n\r\nwhen the server notices a player switching between backend gamestates this is sent to all clients\r\n\r\n    (entity) stateSwitch (fromLevel) (toLevel)    \r\n\r\nwhen the server wants to tell a client to make a sound this may or may not be sent to all clients\r\n\r\n    (entity) sound (soundFile)\r\n\r\n# Packed Representation of Nodes\r\n\r\nThe UDP sockets we've implemented do not allow sending arbitrary tables. To that end, we needed to incorporate a straightforward mechanism as follows:\r\n\r\nWe design these packed representations of nodes to contain only those attributes which the client needs to draw it.\r\n\r\n## Format\r\n\r\nThe string that represents the node is a sequence of parameters, each of which end with `?`\r\n\r\nA parameter is a triplet separated by two `!` s\r\n\r\nThe triplet is identified by TYPE,NAME, and VALUE\r\n\r\n### TYPE \r\n\r\nTYPE is an element of the set {B,N,S}\r\n\r\n`B` indicate the parameter is a boolean\r\n\r\n`N` indicates the parameter is a number\r\n\r\n`S` indicates the parameter is a string\r\n\r\n### NAME\r\n\r\nNAME is the name of the parameter\r\n\r\n### VALUE\r\n\r\nVALUE is the value of the parameter\r\n\r\nExample:\r\n\r\n    S!id!player1729?N!x!100?N!y!200?    \r\n\r\ntranslates to\r\n\r\n    {id=\"player1729\", x=100, y=200}","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}